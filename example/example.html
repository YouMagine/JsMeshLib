<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>JsMeshLib</title>

    <!-- Bootstrap core CSS -->
    <link href="bootstrap/css/bootstrap.css" rel="stylesheet">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>

    <!-- jsMeshLib -->
    <script type="text/javascript" src="../JsMeshLib.js"></script>
    <script type="text/javascript" src="js/example1.js"></script>

    <!-- Custom styles for this template -->
    <link href="jumbotron.css" rel="stylesheet">
    <style type="text/css">
    .greyedOut{color: #999;}
    .greyBg{
      background-color: #eee;
      border-radius: 6px;
      }</style>
      <script type="javascript/worker" id="fileProcessingWorker">



self.onmessage = function(e) {


  // var vertices = [];
  var binString = '';
  var blobData = [];
  var blobDataBody = [];
  var vertexCount = 0;
  postMessage("process start...");
  var time_start = new Date().getTime();

    postMessage("typeof e.data = "+ typeof e.data);
    if(typeof e.data === 'object') {
// 1e keer: count vertices

    var lineStr = '';
    var ui8v1 = new Uint8Array(e.data);
    for(idx = 0 ; idx < e.data.byteLength ; idx++)
    {
      myChars = String.fromCharCode(ui8v1[idx]);

      if((idx%500000)==0){ 
        var progress = +0.4*idx/e.data.byteLength;
        postMessage({progressEvent:progress,statusText:"Analyzing file..."});
      }
            // myChars = String.fromCharCode.apply(null, new Uint8Array(e.data.slice(idx,idx+chunkSize)));
      if((myChars.indexOf("\n") != -1) || (myChars.indexOf("\r") != -1)) {
          // postMessage('Line: '+lineStr);
          pattern = /vertex/g;
          while ( ( result = pattern.exec(lineStr) ) != null ) {
              vertexCount++;
          }
          lineStr = '';
        }
        lineStr += myChars;
    }
    postMessage("Vertices: "+vertexCount);

    // Figure out how large the final ArrayBuffer should be
    faceCount = Math.floor(vertexCount / 3);
    var arrayBufferSize = 80; // header
    arrayBufferSize += 4; // numfaces count
    arrayBufferSize += ((4*12)+2)*faceCount; // numfaces

    postMessage('ArrayBuffer size should be = '+arrayBufferSize+' bytes');

    // Create ArrayBuffer:
    var buffer = new ArrayBuffer(arrayBufferSize);

    // Set the header to 80 times the 'A' char
    var header = new Uint8Array(buffer);
    for(i=0;i<80;i++)
      header[i]=0x20;

    // Add the facecount:
    var vc = new Uint32Array(buffer,80);
    vc[0] = faceCount;




    // Loop
      //var coords = new Float32Array(buffer, 84+50*faceIndex);
      //vertIndex = 0,1,2
    // end loop

    var faceIndex = 0;
    var vertIndex = 0;
    var tmpBuffer = new ArrayBuffer(48);
    var floatArr1 = new Float32Array(tmpBuffer, 0);
    var ui8v1 = new Uint8Array(e.data);
    for(idx = 0 ; idx < e.data.byteLength ; idx++)
    {
      // myChar = String.fromCharCode.apply(null, ui8v1[idx]);
      myChar = String.fromCharCode(ui8v1[idx]);
      if((idx%500000)==0){ 
        var progress = 0.4+0.6*idx/e.data.byteLength;
        postMessage({progressEvent:progress,statusText:"Creating optimzed file..."});
      }

      // postMessage("char: "+myChar);

      if(myChar == "\n" || myChar == "\r" ) {
        // postMessage('Line: '+lineStr);
        pattern = /vertex +([\d|\.|\+|\-|e]+) ([\d|\.|\+|\-|e]+) ([\d|\.|\+|\-|e]+)/g;
        while ( ( result = pattern.exec(lineStr) ) != null ) {
            floatArr1[3+3*vertIndex] = result[1];
            floatArr1[4+3*vertIndex] = result[2];
            floatArr1[5+3*vertIndex] = result[3];
            vertIndex++;
            if(vertIndex == 3) {
              vertIndex = 0;
              // copy data from tmpBuffer to buffer
              var ui8vTmp = new Uint8Array(tmpBuffer);
              var ui8v = new Uint8Array(buffer,84+50*faceIndex);
              for(i=0;i<48;i++){
                ui8v[i] = ui8vTmp[i];
              }
              faceIndex++;
            }
        }
        lineStr = '';
      }//.toString()
      lineStr += myChar;
    }



    var arr = new Array();
    arr.push(buffer);
    blob = new Blob(arr,{type: "application/sla"});

    var duration = new Date().getTime() - time_start;
    postMessage("process finished...\n"+'Processed in: ' + duration + 'ms');
    postMessage({progressEvent:1,statusText: "Finished optimizing in "+ duration + ' ms'});
    postMessage({binaryDone:true,fileBlob:blob,timeTaken:duration});


    return;

/*
UINT8[80] – Header
UINT32 – Number of triangles

foreach triangle
REAL32[3] – Normal vector
REAL32[3] – Vertex 1
REAL32[3] – Vertex 2
REAL32[3] – Vertex 3
UINT16 – Attribute byte count
end*/

      header = e.data.slice(0,5);
      // var lines = String.fromCharCode.apply(null, new Uint8Array(e.data)).split(/[\n\r]/);
      var lineStr = '';
      postMessage("data size: " + e.data.byteLength);
      
      header = new Uint8Array(80);
      for(i=0;i<80;i++)
        header[i]=65;

      blobData.push(header);












      // FIXME: This might not be correct.
      triangleCount = vertCount/3;
      ar1 = new Uint32Array(1);
      ar1[0] = triangleCount;
      blobData.push(ar1);
      // blobData.push(blobDataBody);
      //TODO: try catch block
      blob = new Blob(blobDataBody,{type: "application/sla"});
//blobDataBody


      // postMessage(vertices);
      postMessage({binaryDone:true,fileBlob:blob});
      // postMessage(blobData);
      postMessage("VertCount: "+vertCount+' trianglecount: ' +triangleCount);
      // var blob = bb.getBlob("example/binary");
      // saveAs(blob, "DoubleHelix_attempt.stl");

      // postMessage({data:binString});
        // var faceCount = vertices.length / 3;
        // for(var i=0; i<faceCount;i++)
        // {
            // geometry.faces.push(face3(i*3, i*3+2, i*3+1));
      // }

    }
    if(typeof e.data === 'string') 
      postMessage(e.data); // Pass through.
  


};
  </script>
  <script>

var lastMessageIn;

function loadInlineWorker(selector, callback) {
  window.URL = window.URL || window.webkitURL || null;

  var script = document.querySelector(selector);
  if (script.type === 'javascript/worker') {
    var blob = new Blob([script.textContent]);
    return new Worker(window.URL.createObjectURL(blob));
  }
}


var worker = loadInlineWorker('#fileProcessingWorker');
var fileData;
var lastProgress = -1;


worker.addEventListener('message', function(e) {
  lastMessageIn = e.data;
  if(typeof e.data === 'object') {
    o = e.data;
    if(progress = o.progressEvent) {
      $('#waitForStep2').hide();
      progressBarPerc(progress*100,o.statusText || '');
      if(progress == 1) setTimeout(function(){$('#conversionInfo').hide();},4000);
      return; // no more handing of the message is desired
    }
    // postMessage("HEX: "+arrayBufferToHexString(e.data));

    if(o.binaryDone){
      console.log('Worker finished the binary!!!! ');
      $('#newFileStats').attr('style','');
      numKBytes = e.data.fileBlob.size / 1024;
      $('#newSize').html(parseInt(numKBytes*10)/10 + ' kb');
      $('#newSizeShrunk').html(parseInt((numKBytes/(fileData.size/1024)*100))+'%');
      if(o.timeTaken) $('#timeTaken').html(o.timeTaken+' ms');
      window.URL = window.URL || window.webkitURL || null;
      var a = document.createElement('a');
      a.href = window.URL.createObjectURL(e.data.fileBlob);
      a.download = fileData.name;
      a.click();
    }
  }

  console.log('Worker said: ', e.data);
}, false);


worker.postMessage('Hello World'); // Send data to our worker.

function handleFileSelect(evt) {
  evt.target.disabled = true;
  console.log("You selected a file...");
  $('#fName').html('test.stl');
  if(fileInput.files.length){
    console.log('yes.',evt.target.files[0]);
    $('#fName').html(evt.target.files[0].name);
    $('#fType').html(evt.target.files[0].type);
    $('#fSize').html(parseInt(evt.target.files[0].size/1024)+' kb');
    $('#fLast').html(evt.target.files[0].lastModifiedDate);
  }

  header = evt.target.files[0].slice(0,5);
  fileData = evt.target.files[0];

  reader = new FileReader();
  reader.onload = function (evt) {
    data = evt.target.result;
    // if(txt.toLowerCase() === 'solid') {
      // console.log("Seems to be an ASCII STL... we can try to convert this...");
      // worker.postMessage("hey, worker... give this a try...");
      // reader2 = new FileReader();
      // reader2.onload = function (evt) {
        // data = evt.target.result;
        // worker.postMessage(data);
      // }
      // reader2.readAsArrayBuffer(fileData);
      worker.postMessage(data);
    // }
  }
  // var solidTest = evt.target.files[0];//.slice(0, 5);
  reader.readAsArrayBuffer(fileData);

  evt.target.disabled = false;
}
  // worker.postMessage(evt.target.files[0]);

$(function() {
  // Stuff to do as soon as the DOM is ready;
  var fileInput = document.getElementById("fileInput");
  fileInput.addEventListener('change', handleFileSelect);



});

function pad(str ) {
    return str.length < 2 ? "0" + str : str;
}

function arrayBufferToHexString(buffer) {
  // Display the binary output as hex:
  var hexArray = [].map.call( buffer, function(v) {
    return pad(v.toString(16));
  });
  var out='';
  for(i = 0; i < hexArray.length; i+=8) { 
    out += hexArray[i]+hexArray[i+1]+' '+hexArray[i+2]+hexArray[i+3]+' '+hexArray[i+4]+hexArray[i+5]+' '+hexArray[i+6]+hexArray[i+7]+"\n";
  }
  return out;  
}

function progressBarPerc(perc,statusText){
  $('#conversionProgressDiv').css('visibility','');
  perc = parseInt(progress*100);
  $('#conversionProgressStatus').html(statusText);
  if(perc >= 100)
    perc = 100;
      $('#conversionProgressBar').css('width',perc + '%');
  if(perc == 100)
    $('#conversionProgressDiv').removeClass('active');
}


</script>
  </head>

  <body>

    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="#">jsMeshLib: Examples</a>
        <div class="nav-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#">Home</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Examples <b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="#">1: STL Compression</a></li>
                <li class="divider"></li>
                <li class="dropdown-header">Nav header</li>
                <li><a href="#">2: Example 2 (TBD)</a></li>
              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

    <div class="container">

      <!-- Main jumbotron for a primary marketing message or call to action -->
      <div class="jumbotron">
        <h1>Client side STL compression</h1>
        <p>This example shows how compression on the client side can help speed up transfers by an order of magnitude (e.g. in the case of ASCII STL files.</p>
        <p><a class="btn btn-primary btn-large">Click to start uploading &raquo;</a></p>
      </div>

      <div class="body-content">

        <!-- Example row of columns -->
        <div class="row">
          <div class="col-lg-4 greyBg">
            <h2>Step 1: Select a file</h2>
            <p>Select a file or drop it onto this area.</p>
            <input type="file" id="fileInput" />
            <fieldset id="fileInfo">
              <legend>File details</legend>
              <p>File name: <span id="fName" class="greyedOut">(unknown)</span></p>
              <p>File size: <span id="fSize" class="greyedOut">(unknown)</span></p>
              <p>File type: <span id="fType" class="greyedOut">(unknown)</span></p>
              <p>File changed: <span id="fLast" class="greyedOut">(unknown)</span></p>
            </fieldset>
          </div>
          <div class="col-lg-4">
            <h2>Step 2: Choose compression</h2>
            <p>Choose which compression you want.</p>
            <p><input name="comp" type="radio" id="noComp" checked /> <label for="noComp">No compression</label></p>
            <p><input name="comp" type="radio" id="noComp" /> <label for="noComp">Convert to binary (if applicable)</label></p>
            <p><input name="comp" type="radio" id="noComp" /> <label for="noComp">Convert and Zip</label></p>
            <p><a class="btn btn-default" href="#">View details &raquo;</a></p>
         </div>
          <div class="col-lg-4">
            <h2>Step 3: Evaluate the difference</h2>
            <p id="waitForStep2" class="greyedOut">Finish step 2 first...</p>
            <div id="conversionInfo">
              <b id="conversionProgressStatus"></b>
            <div id="conversionProgressDiv" style="visibility:hidden" class="progress progress-striped active">
              <div id="conversionProgressBar" class="progress-bar" style="width: 0%"></div>
            </div>
            </div>
            <div id="newFileStats" style="visibility:hidden">
              <p>New file size: <span id="newSize" class="greyedOut">(unknown)</span></p>
              <p>Relative size: <span id="newSizeShrunk" class="greyedOut">(unknown)</span></p>
              <p>Processing time: <span id="timeTaken" class="greyedOut">(unknown)</span></p>
            </div>
          </div>
        </div>

        <hr>

        <footer>
          <p>&copy; Erik de Bruijn - Ultimaker 2013</p>
        </footer>
      </div>

    </div> <!-- /container -->

    <script src="../assets/js/jquery.js"></script>
    <script src="../bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>